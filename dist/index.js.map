{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;ACVO;AACP;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oBAAoB;AACd;AACP;AACA;AACA;AACA;AACA,CAAC,4BAA4B;;;;;;;;;;;;;;;;;;;;;ACpBwB;AACJ;AACjD;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA,sBAAsB,oDAAa;AACnC,UAAU;AACV;AACA;AACA;AACA,sBAAsB,oDAAa;AACnC,SAAS;AACT;AACA;AACA;AACA;AACO;AACP,6BAA6B,0CAAM,EAAE,0CAAM,EAAE,0CAAM,EAAE,0CAAM,EAAE,0CAAM,EAAE,0CAAM;AAC3E,SAAS,0CAAM,GAAG,+CAAW;AAC7B,SAAS,0CAAM,GAAG,+CAAW;AAC7B,SAAS,0CAAM,GAAG,+CAAW;AAC7B,SAAS,0CAAM,GAAG,+CAAW;AAC7B,SAAS,0CAAM,GAAG,+CAAW;AAC7B,SAAS,0CAAM,GAAG,+CAAW;AAC7B,KAAK;AACL,QAAQ,mDAAe;AACvB,QAAQ,6DAAyB;AACjC,QAAQ,sDAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,kBAAkB;AACtC;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,0BAA0B,oDAAa;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA,sBAAsB,oDAAa;AACnC;AACA,SAAS;AACT;AACA;AACA;AACO;AACP,6BAA6B,0CAAM,EAAE,0CAAM,EAAE,0CAAM,EAAE,0CAAM;AAC3D,SAAS,0CAAM;AACf,SAAS,0CAAM;AACf,SAAS,0CAAM;AACf,SAAS,0CAAM;AACf,KAAK;AACL,QAAQ,6DAAyB;AACjC,QAAQ,sDAAkB;AAC1B;AACA;AACO;AACP,kCAAkC,0CAAM,EAAE,0CAAM,EAAE,0CAAM,EAAE,0CAAM;AAChE,SAAS,0CAAM;AACf,SAAS,0CAAM;AACf,SAAS,0CAAM;AACf,SAAS,0CAAM;AACf,KAAK;AACL,QAAQ,6DAAyB;AACjC,QAAQ,sDAAkB;AAC1B;AACA,IAAI,8CAAO;AACX;AACA,uBAAuB,oDAAa,EAAE,sDAAkB,EAAE,6DAAyB;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,sBAAsB,oDAAa;AACnC,yBAAyB,oDAAa;AACtC,UAAU;AACV;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtNO;AACP;AACA;AACA;AACA;AACA;AACO;AACP,iCAAiC,4BAA4B;AAC7D;AACA,gBAAgB,OAAO;AACvB;;;;;;;UCVA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;;ACNiK;AACjK;AACA,2CAA2C,WAAW;AACtD;AACA,cAAc,WAAW,EAAE,UAAU,EAAE,eAAe,EAAE,cAAc;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,4BAA4B,0EAAoB;AAChD;AACO;AACP,4BAA4B,8EAAwB;AACpD;AACO;AACP,4BAA4B,8EAAwB;AACpD;AACO;AACP,4BAA4B,2EAAqB;AACjD;AACO;AACP,WAAW,6EAAuB;AAClC,4BAA4B,SAAS,IAAI,YAAY;AACrD;AACA","sources":["webpack://sr-scrambler/webpack/universalModuleDefinition","webpack://sr-scrambler/./src/enums.ts","webpack://sr-scrambler/./src/scrambler/scrambler.ts","webpack://sr-scrambler/./src/util.ts","webpack://sr-scrambler/webpack/bootstrap","webpack://sr-scrambler/webpack/runtime/define property getters","webpack://sr-scrambler/webpack/runtime/hasOwnProperty shorthand","webpack://sr-scrambler/webpack/runtime/make namespace object","webpack://sr-scrambler/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sr-scrambler\"] = factory();\n\telse\n\t\troot[\"sr-scrambler\"] = factory();\n})(self, () => {\nreturn ","export var CubePlane;\n(function (CubePlane) {\n    CubePlane[\"X\"] = \"x\";\n    CubePlane[\"Y\"] = \"y\";\n    CubePlane[\"Z\"] = \"z\";\n})(CubePlane || (CubePlane = {}));\nexport var Side;\n(function (Side) {\n    Side[\"L\"] = \"L\";\n    Side[\"R\"] = \"R\";\n    Side[\"U\"] = \"U\";\n    Side[\"D\"] = \"D\";\n    Side[\"F\"] = \"F\";\n    Side[\"B\"] = \"B\";\n})(Side || (Side = {}));\nexport var Modifier;\n(function (Modifier) {\n    Modifier[\"Double\"] = \"2\";\n    Modifier[\"CounterClockwise\"] = \"'\";\n    Modifier[\"Clockwise\"] = \"\";\n})(Modifier || (Modifier = {}));\n","import { CubePlane, Modifier, Side } from \"../enums\";\nimport { randomElement, shuffle } from \"../util\";\nconst generateScramble = (faces, planeMapping, modifiers, maxDepth, numTurns) => {\n    let turns = [];\n    let previousTurn;\n    let newTurn;\n    for (var i = 0; i < numTurns; i++) {\n        do {\n            newTurn = randomElement(faces);\n        } while (planeMapping[previousTurn] === planeMapping[newTurn]);\n        turns.push({\n            face: newTurn,\n            depth: Math.floor(Math.random() * maxDepth) + 1,\n            modifier: randomElement(modifiers)\n        });\n        previousTurn = newTurn;\n    }\n    return turns;\n};\nexport const generateCubeScramble = (size = 3, numTurns = 21) => {\n    return generateScramble([Side.L, Side.R, Side.U, Side.D, Side.F, Side.B], {\n        [Side.L]: CubePlane.X,\n        [Side.R]: CubePlane.X,\n        [Side.U]: CubePlane.Y,\n        [Side.D]: CubePlane.Y,\n        [Side.F]: CubePlane.Z,\n        [Side.B]: CubePlane.Z\n    }, [\n        Modifier.Double,\n        Modifier.CounterClockwise,\n        Modifier.Clockwise\n    ], Math.floor(size / 2), numTurns);\n};\nconst pochmanFaces = ['D', 'R'];\nconst pochmanModifiers = ['++', '--'];\n/**\n * generates a pochman scramble for the megaminx\n */\nexport const generateMegaminxScramble = (sequenceLength = 10, numSequences = 6) => {\n    let turns = [];\n    for (let i = 0; i < numSequences; i++) {\n        turns[i] = [];\n        for (let j = 0; j < sequenceLength; j++) {\n            turns[i].push({\n                face: pochmanFaces[j % pochmanFaces.length],\n                modifier: randomElement(pochmanModifiers),\n                depth: 1\n            });\n        }\n        turns[i].push({\n            face: 'U',\n            modifier: randomElement(['', '\\'']),\n            depth: 1\n        });\n    }\n    return turns;\n};\nexport const generateSkewbScramble = (numTurns = 9) => {\n    return generateScramble([Side.L, Side.R, Side.U, Side.B], {\n        [Side.L]: 'L',\n        [Side.R]: 'R',\n        [Side.U]: 'U',\n        [Side.B]: 'B'\n    }, [\n        Modifier.CounterClockwise,\n        Modifier.Clockwise\n    ], 1, numTurns);\n};\nexport const generatePyraminxScramble = (numTurns = 10) => {\n    let turns = generateScramble([Side.L, Side.R, Side.U, Side.B], {\n        [Side.L]: 'L',\n        [Side.R]: 'R',\n        [Side.U]: 'U',\n        [Side.B]: 'B'\n    }, [\n        Modifier.CounterClockwise,\n        Modifier.Clockwise\n    ], 1, numTurns);\n    shuffle(['l', 'r', 'u', 'b'])\n        .forEach(point => {\n        let modifier = randomElement([Modifier.Clockwise, Modifier.CounterClockwise, null]);\n        if (modifier != null) {\n            turns.push({\n                face: point,\n                modifier: modifier,\n                depth: 1\n            });\n        }\n    });\n    return turns;\n};\nexport const generateSquare1Scramble = (numTurns = 12) => {\n    let tops = [2, 1, 2, 1, 2, 1, 2, 1];\n    let bottom = [1, 2, 1, 2, 1, 2, 1, 2];\n    const turnTop = (turns) => {\n        while (turns != 0) {\n            if (turns < 0) {\n                let piece = tops.shift();\n                turns += piece;\n                tops.push(piece);\n            }\n            else if (turns > 0) {\n                let piece = tops.pop();\n                turns -= piece;\n                tops.unshift(piece);\n            }\n        }\n    };\n    const turnBottom = (turns) => {\n        while (turns != 0) {\n            if (turns < 0) {\n                let piece = bottom.shift();\n                turns += piece;\n                bottom.push(piece);\n            }\n            else if (turns > 0) {\n                let piece = bottom.pop();\n                turns -= piece;\n                bottom.unshift(piece);\n            }\n        }\n    };\n    const slice = () => {\n        let topNum = 0;\n        let bottomNum = 0;\n        let value = 0;\n        for (let i = tops.length; i > 0 && value < 6; i--) {\n            value += tops[i - 1];\n            topNum++;\n        }\n        value = 0;\n        for (let i = 0; i < bottom.length && value < 6; i++) {\n            value += bottom[i];\n            bottomNum++;\n        }\n        const topSlice = tops.splice(tops.length - topNum, tops.length);\n        const bottomSlice = bottom.splice(0, bottomNum);\n        tops = tops.concat(bottomSlice);\n        bottom = topSlice.concat(bottom);\n    };\n    const isLayerAligned = (layer) => {\n        let value = 0;\n        for (let i = 0; i < layer.length && value < 6; i++) {\n            value += layer[i];\n            if (value > 6) {\n                return false;\n            }\n        }\n        return true;\n    };\n    const isMovePossible = (layer, turns) => {\n        if (turns < 0) {\n            // Take off front, put on end\n            while (turns < 0) {\n                let piece = layer.shift();\n                if (piece > Math.abs(turns)) {\n                    return false;\n                }\n                turns += piece;\n                layer.push(piece);\n            }\n            return isLayerAligned(layer);\n        }\n        else if (turns > 0) {\n            // Take off end, put on front\n            while (turns > 0) {\n                let piece = layer.pop();\n                if (turns < piece) {\n                    return false;\n                }\n                turns -= piece;\n                layer.unshift(piece);\n            }\n            return isLayerAligned(layer);\n        }\n        else {\n            // Turns = 0, should be possible\n            return true;\n        }\n    };\n    const possibleMoves = () => {\n        let possibleTop = [];\n        let possibleBottom = [];\n        for (let i = -6; i <= 6; i++) {\n            if (isMovePossible([...tops], i)) {\n                possibleTop.push(i);\n            }\n            if (isMovePossible([...bottom], i)) {\n                possibleBottom.push(i);\n            }\n        }\n        return {\n            possibleTop,\n            possibleBottom\n        };\n    };\n    let turns = [];\n    for (let i = 0; i < numTurns; i++) {\n        let moves = possibleMoves();\n        let topMove = 0;\n        let bottomMove = 0;\n        do {\n            topMove = randomElement(moves.possibleTop);\n            bottomMove = randomElement(moves.possibleBottom);\n        } while (topMove === 0 && bottomMove === 0);\n        turns.push({\n            top: topMove,\n            bottom: bottomMove\n        });\n        turnTop(topMove);\n        turnBottom(bottomMove);\n        slice();\n    }\n    return turns;\n};\n","export function randomElement(array) {\n    if (!Array.isArray(array) || array.length < 1) {\n        return null;\n    }\n    return array[Math.floor(Math.random() * array.length)];\n}\nexport function shuffle(array) {\n    return array.map(value => ({ value, sort: Math.random() }))\n        .sort((a, b) => a.sort - b.sort)\n        .map(({ value }) => value);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { generateSquare1Scramble, generateCubeScramble, generateMegaminxScramble, generatePyraminxScramble, generateSkewbScramble } from \"./scrambler/scrambler\";\nconst turnToString = (turn) => {\n    const depthLayer = turn.depth > 2 ? `${turn.depth}` : '';\n    const sliceIndicator = turn.depth > 1 ? 'w' : '';\n    return `${depthLayer}${turn.face}${sliceIndicator}${turn.modifier}`;\n};\nconst scrambleToString = (turns) => {\n    return turns\n        .map(turn => {\n        if (Array.isArray(turn)) {\n            return scrambleToString(turn) + '\\n';\n        }\n        else {\n            return turnToString(turn);\n        }\n    })\n        .join(' ');\n};\nexport const cube = (size = 3, numTurns = 21) => {\n    return scrambleToString(generateCubeScramble(size, numTurns));\n};\nexport const megaminx = () => {\n    return scrambleToString(generateMegaminxScramble());\n};\nexport const pyraminx = (numTurns) => {\n    return scrambleToString(generatePyraminxScramble(numTurns));\n};\nexport const skewb = (numTurns) => {\n    return scrambleToString(generateSkewbScramble(numTurns));\n};\nexport const square1 = (numTurns) => {\n    return generateSquare1Scramble(numTurns)\n        .map((turn) => ` (${turn.top}, ${turn.bottom}) /`)\n        .join('');\n};\n"],"names":[],"sourceRoot":""}