{"version":3,"file":"index.js","mappings":"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","sources":["webpack://sr-scrambler/webpack/universalModuleDefinition","webpack://sr-scrambler/webpack/bootstrap","webpack://sr-scrambler/./src/enums.ts","webpack://sr-scrambler/webpack/runtime/define property getters","webpack://sr-scrambler/webpack/runtime/hasOwnProperty shorthand","webpack://sr-scrambler/webpack/runtime/make namespace object","webpack://sr-scrambler/./src/util.ts","webpack://sr-scrambler/./src/scrambler/scrambler.ts","webpack://sr-scrambler/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"sr-scrambler\"] = factory();\n\telse\n\t\troot[\"sr-scrambler\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","export var CubePlane;\n(function (CubePlane) {\n    CubePlane[\"X\"] = \"x\";\n    CubePlane[\"Y\"] = \"y\";\n    CubePlane[\"Z\"] = \"z\";\n})(CubePlane || (CubePlane = {}));\nexport var Side;\n(function (Side) {\n    Side[\"L\"] = \"L\";\n    Side[\"R\"] = \"R\";\n    Side[\"U\"] = \"U\";\n    Side[\"D\"] = \"D\";\n    Side[\"F\"] = \"F\";\n    Side[\"B\"] = \"B\";\n})(Side || (Side = {}));\nexport var Modifier;\n(function (Modifier) {\n    Modifier[\"Double\"] = \"2\";\n    Modifier[\"CounterClockwise\"] = \"'\";\n    Modifier[\"Clockwise\"] = \"\";\n})(Modifier || (Modifier = {}));\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export function randomElement(array) {\n    if (!Array.isArray(array) || array.length < 1) {\n        return null;\n    }\n    return array[Math.floor(Math.random() * array.length)];\n}\nexport function shuffle(array) {\n    return array.map(value => ({ value, sort: Math.random() }))\n        .sort((a, b) => a.sort - b.sort)\n        .map(({ value }) => value);\n}\n","import { CubePlane, Modifier, Side } from \"../enums\";\nimport { randomElement, shuffle } from \"../util\";\nconst generateScramble = (faces, planeMapping, modifiers, maxDepth, numTurns) => {\n    let turns = [];\n    let previousTurn;\n    let newTurn;\n    for (var i = 0; i < numTurns; i++) {\n        do {\n            newTurn = randomElement(faces);\n        } while (planeMapping[previousTurn] === planeMapping[newTurn]);\n        turns.push({\n            face: newTurn,\n            depth: Math.floor(Math.random() * maxDepth) + 1,\n            modifier: randomElement(modifiers)\n        });\n        previousTurn = newTurn;\n    }\n    return turns;\n};\nexport const generateCubeScramble = (size = 3, numTurns = 21) => {\n    return generateScramble([Side.L, Side.R, Side.U, Side.D, Side.F, Side.B], {\n        [Side.L]: CubePlane.X,\n        [Side.R]: CubePlane.X,\n        [Side.U]: CubePlane.Y,\n        [Side.D]: CubePlane.Y,\n        [Side.F]: CubePlane.Z,\n        [Side.B]: CubePlane.Z\n    }, [\n        Modifier.Double,\n        Modifier.CounterClockwise,\n        Modifier.Clockwise\n    ], Math.floor(size / 2), numTurns);\n};\nconst pochmanFaces = ['D', 'R'];\nconst pochmanModifiers = ['++', '--'];\n/**\n * generates a pochman scramble for the megaminx\n */\nexport const generateMegaminxScramble = (sequenceLength = 10, numSequences = 6) => {\n    let turns = [];\n    for (let i = 0; i < numSequences; i++) {\n        turns[i] = [];\n        for (let j = 0; j < sequenceLength; j++) {\n            turns[i].push({\n                face: pochmanFaces[j % pochmanFaces.length],\n                modifier: randomElement(pochmanModifiers),\n                depth: 1\n            });\n        }\n        turns[i].push({\n            face: 'U',\n            modifier: randomElement(['', '\\'']),\n            depth: 1\n        });\n    }\n    return turns;\n};\nexport const generateSkewbScramble = (numTurns = 9) => {\n    return generateScramble([Side.L, Side.R, Side.U, Side.B], {\n        [Side.L]: 'L',\n        [Side.R]: 'R',\n        [Side.U]: 'U',\n        [Side.B]: 'B'\n    }, [\n        Modifier.CounterClockwise,\n        Modifier.Clockwise\n    ], 1, numTurns);\n};\nexport const generatePyraminxScramble = (numTurns = 10) => {\n    let turns = generateScramble([Side.L, Side.R, Side.U, Side.B], {\n        [Side.L]: 'L',\n        [Side.R]: 'R',\n        [Side.U]: 'U',\n        [Side.B]: 'B'\n    }, [\n        Modifier.CounterClockwise,\n        Modifier.Clockwise\n    ], 1, numTurns);\n    shuffle(['l', 'r', 'u', 'b'])\n        .forEach(point => {\n        let modifier = randomElement([Modifier.Clockwise, Modifier.CounterClockwise, null]);\n        if (modifier != null) {\n            turns.push({\n                face: point,\n                modifier: modifier,\n                depth: 1\n            });\n        }\n    });\n    return turns;\n};\nexport const generateSquare1Scramble = (numTurns = 12) => {\n    let tops = [2, 1, 2, 1, 2, 1, 2, 1];\n    let bottom = [1, 2, 1, 2, 1, 2, 1, 2];\n    const turnTop = (turns) => {\n        while (turns != 0) {\n            if (turns < 0) {\n                let piece = tops.shift();\n                turns += piece;\n                tops.push(piece);\n            }\n            else if (turns > 0) {\n                let piece = tops.pop();\n                turns -= piece;\n                tops.unshift(piece);\n            }\n        }\n    };\n    const turnBottom = (turns) => {\n        while (turns != 0) {\n            if (turns < 0) {\n                let piece = bottom.shift();\n                turns += piece;\n                bottom.push(piece);\n            }\n            else if (turns > 0) {\n                let piece = bottom.pop();\n                turns -= piece;\n                bottom.unshift(piece);\n            }\n        }\n    };\n    const slice = () => {\n        let topNum = 0;\n        let bottomNum = 0;\n        let value = 0;\n        for (let i = tops.length; i > 0 && value < 6; i--) {\n            value += tops[i - 1];\n            topNum++;\n        }\n        value = 0;\n        for (let i = 0; i < bottom.length && value < 6; i++) {\n            value += bottom[i];\n            bottomNum++;\n        }\n        const topSlice = tops.splice(tops.length - topNum, tops.length);\n        const bottomSlice = bottom.splice(0, bottomNum);\n        tops = tops.concat(bottomSlice);\n        bottom = topSlice.concat(bottom);\n    };\n    const isLayerAligned = (layer) => {\n        let value = 0;\n        for (let i = 0; i < layer.length && value < 6; i++) {\n            value += layer[i];\n            if (value > 6) {\n                return false;\n            }\n        }\n        return true;\n    };\n    const isMovePossible = (layer, turns) => {\n        if (turns < 0) {\n            // Take off front, put on end\n            while (turns < 0) {\n                let piece = layer.shift();\n                if (piece > Math.abs(turns)) {\n                    return false;\n                }\n                turns += piece;\n                layer.push(piece);\n            }\n            return isLayerAligned(layer);\n        }\n        else if (turns > 0) {\n            // Take off end, put on front\n            while (turns > 0) {\n                let piece = layer.pop();\n                if (turns < piece) {\n                    return false;\n                }\n                turns -= piece;\n                layer.unshift(piece);\n            }\n            return isLayerAligned(layer);\n        }\n        else {\n            // Turns = 0, should be possible\n            return true;\n        }\n    };\n    const possibleMoves = () => {\n        let possibleTop = [];\n        let possibleBottom = [];\n        for (let i = -6; i <= 6; i++) {\n            if (isMovePossible([...tops], i)) {\n                possibleTop.push(i);\n            }\n            if (isMovePossible([...bottom], i)) {\n                possibleBottom.push(i);\n            }\n        }\n        return {\n            possibleTop,\n            possibleBottom\n        };\n    };\n    let turns = [];\n    for (let i = 0; i < numTurns; i++) {\n        let moves = possibleMoves();\n        let topMove = 0;\n        let bottomMove = 0;\n        do {\n            topMove = randomElement(moves.possibleTop);\n            bottomMove = randomElement(moves.possibleBottom);\n        } while (topMove === 0 && bottomMove === 0);\n        turns.push({\n            top: topMove,\n            bottom: bottomMove\n        });\n        turnTop(topMove);\n        turnBottom(bottomMove);\n        slice();\n    }\n    return turns;\n};\n","import { generateSquare1Scramble, generateCubeScramble, generateMegaminxScramble, generatePyraminxScramble, generateSkewbScramble } from \"./scrambler/scrambler\";\nconst turnToString = (turn) => {\n    const depthLayer = turn.depth > 2 ? `${turn.depth}` : '';\n    const sliceIndicator = turn.depth > 1 ? 'w' : '';\n    return `${depthLayer}${turn.face}${sliceIndicator}${turn.modifier}`;\n};\nconst scrambleToString = (turns) => {\n    return turns\n        .map(turn => {\n        if (Array.isArray(turn)) {\n            return scrambleToString(turn) + '\\n';\n        }\n        else {\n            return turnToString(turn);\n        }\n    })\n        .join(' ');\n};\nexport const cube = (size = 3, numTurns = 21) => {\n    return scrambleToString(generateCubeScramble(size, numTurns));\n};\nexport const megaminx = () => {\n    return scrambleToString(generateMegaminxScramble());\n};\nexport const pyraminx = (numTurns) => {\n    return scrambleToString(generatePyraminxScramble(numTurns));\n};\nexport const skewb = (numTurns) => {\n    return scrambleToString(generateSkewbScramble(numTurns));\n};\nexport const square1 = (numTurns) => {\n    return generateSquare1Scramble(numTurns)\n        .map((turn) => ` (${turn.top}, ${turn.bottom}) /`)\n        .join('');\n};\n"],"names":["root","factory","exports","module","define","amd","self","CubePlane","Side","Modifier","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","randomElement","array","Array","isArray","length","Math","floor","random","generateScramble","faces","planeMapping","modifiers","maxDepth","numTurns","previousTurn","newTurn","turns","i","push","face","depth","modifier","pochmanFaces","pochmanModifiers","scrambleToString","map","turn","depthLayer","sliceIndicator","turnToString","join","cube","size","L","R","U","D","F","B","X","Y","Z","Double","CounterClockwise","Clockwise","generateCubeScramble","megaminx","sequenceLength","numSequences","j","generateMegaminxScramble","pyraminx","sort","a","b","forEach","point","generatePyraminxScramble","skewb","generateSkewbScramble","square1","tops","bottom","turnTop","piece","shift","pop","unshift","turnBottom","slice","topNum","bottomNum","topSlice","splice","bottomSlice","concat","isLayerAligned","layer","isMovePossible","abs","possibleMoves","possibleTop","possibleBottom","moves","topMove","bottomMove","top","generateSquare1Scramble"],"sourceRoot":""}